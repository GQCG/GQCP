// This file is part of GQCG-gqcp.
// 
// Copyright (C) 2017-2019  the GQCG developers
// 
// GQCG-gqcp is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// GQCG-gqcp is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with GQCG-gqcp.  If not, see <http://www.gnu.org/licenses/>.
// 
#define BOOST_TEST_MODULE "FockSpace"

#include <boost/test/unit_test.hpp>

#include "FockSpace/FockSpace.hpp"
#include "FockSpace/ProductFockSpace.hpp"
#include "FockSpace/SelectedFockSpace.hpp"
#include "Operator/SecondQuantized/SQHamiltonian.hpp"


/**
 *  Test the Fock space constructor
 */
BOOST_AUTO_TEST_CASE ( FockSpace_constructor ) {

    BOOST_CHECK_NO_THROW(GQCP::FockSpace (10, 5));
}


/**
 *  Test if the expansions generated by the Fock space are normalized.
 */
BOOST_AUTO_TEST_CASE ( expansions ) {

    // Check the BaseFockSpace expansion functions
    GQCP::FockSpace fock_space (8, 3);

    GQCP::VectorX<double> hartree_fock_expansion = fock_space.HartreeFockExpansion();
    BOOST_CHECK(std::abs(hartree_fock_expansion.norm() - 1.0) < 1.0e-12);  // check if normalized
    BOOST_CHECK(std::abs(hartree_fock_expansion(0) - 1.0) < 1.0e-12);  // the Hartree-Fock determinant should be the first one

    GQCP::VectorX<double> random_expansion = fock_space.randomExpansion();
    BOOST_CHECK(std::abs(random_expansion.norm() - 1.0) < 1.0e-12);  // check if normalized

    GQCP::VectorX<double> constant_expansion = fock_space.constantExpansion();
    BOOST_CHECK(std::abs(constant_expansion.norm() - 1.0) < 1.0e-12);  // check if normalized
}


/**
 *  Check if the static Fock space dimension calculation is correct and if it can throw errors
 */
BOOST_AUTO_TEST_CASE ( FockSpace_dimension ) {

    BOOST_CHECK_EQUAL(GQCP::FockSpace::calculateDimension(10, 1), 10);
    BOOST_CHECK_EQUAL(GQCP::FockSpace::calculateDimension(6, 2), 15);
    BOOST_CHECK_EQUAL(GQCP::FockSpace::calculateDimension(8, 3), 56);

    BOOST_CHECK_THROW(GQCP::FockSpace::calculateDimension(100, 50), std::overflow_error);
}


/**
 *  Test if the vertex weights of the Fock space addressing scheme are correct
 */
BOOST_AUTO_TEST_CASE ( vertex_weights_K5_N3 ) {

    // Let's test an addressing scheme for K=5 and N=3 (5 MOs and 3 alpha electrons)
    GQCP::FockSpace fock_space = GQCP::FockSpace(5, 3);

    GQCP::Matrixu ref_vertex_weights = {{1, 0, 0, 0},
                                        {1, 1, 0, 0},
                                        {1, 2, 1, 0},
                                        {0, 3, 3, 1},
                                        {0, 0, 6, 4},
                                        {0, 0, 0, 10}};
    BOOST_CHECK(ref_vertex_weights == fock_space.get_vertex_weights());
}


/**
 *  Test if the shift in address and orbital indices correspond to the correct solutions
 *  
 *  This method does not alter the ONVs in any way.
 */
BOOST_AUTO_TEST_CASE ( iterateToNextUnoccupiedOrbital ) {

    GQCP::FockSpace fock_space (5, 3);
    GQCP::ONV onv = fock_space.makeONV(3);  // 01110

    size_t address_shift = 0;
    // test shift if we annihilate one electron and start from orbital index 2
    size_t e = 1;  // count starts at 1 (translates to orbital index 2)
    size_t q = 2;  // index starts at orbital index 2

    //  In this instance electron weights at index 2 and 3 should be shifted.
    //  Initial weight contributions were 1 and 1 respectively,
    //  these should be shifted to 2 and 3 respectively, the difference is 1 and 2 respectively.
    //  The total shift is thus 3
    fock_space.shiftUntilNextUnoccupiedOrbital<1>(onv, address_shift, q, e);

    BOOST_CHECK(address_shift == 3);
    BOOST_CHECK(e == 3);
    BOOST_CHECK(q == 4);

    // test shift if we annihilate two electrons and start from orbital index 3
    e = 2;  // count starts at 2 (translates to orbital index 3)
    q = 3;  // index starts at orbital index 3

    //  In this instance electron weights at index 3 should be shifted.
    //  The initial weight contribution was 1,
    //  this should be shifted to 3, the difference is 2
    //  The total shift is thus 2
    address_shift = 0;
    fock_space.shiftUntilNextUnoccupiedOrbital<2>(onv, address_shift, q, e);

    BOOST_CHECK(address_shift == 2);
    BOOST_CHECK(e == 3);
    BOOST_CHECK(q == 4);
}


/**
 *  Test if the shift in address, orbital indices and sign change correspond to the correct solutions
 *  
 *  This method does not alter the ONVs in any way.
 */
BOOST_AUTO_TEST_CASE ( iterateToNextUnoccupiedOrbital_signed ) {

    GQCP::FockSpace fock_space (5, 3);
    GQCP::ONV onv = fock_space.makeONV(3);  // 01110

    size_t address_shift = 0;
    int sign = 1;
    // test shift if we annihilate one electron and start from orbital index 2
    size_t e = 1;  // count starts at 1 (translates to orbital index 2)
    size_t q = 2;  // index starts at orbital index 2

    //  In this instance electron weights at index 2 and 3 should be shifted.
    //  Initial weight contributions were 1 and 1 respectively,
    //  these should be shifted to 2 and 3 respectively, the difference is 1 and 2 respectively.
    //  The total shift is thus 3, and the sign should remain the same (flips twice)
    fock_space.shiftUntilNextUnoccupiedOrbital<1>(onv, address_shift, q, e, sign);

    BOOST_CHECK(address_shift == 3);
    BOOST_CHECK(e == 3);
    BOOST_CHECK(q == 4);
    BOOST_CHECK(sign == 1);

    // test shift if we annihilate two electrons and start from orbital index 3
    e = 2;  // count starts at 2 (translates to orbital index 3)
    q = 3;  // index starts at orbital index 3

    //  In this instance electron weights at index 3 should be shifted.
    //  The initial weight contribution was 1,
    //  this should be shifted to 3, the difference is 2
    //  The total shift is thus 2, sign should flip once
    address_shift = 0;
    fock_space.shiftUntilNextUnoccupiedOrbital<2>(onv, address_shift, q, e, sign);

    BOOST_CHECK(address_shift == 2);
    BOOST_CHECK(e == 3);
    BOOST_CHECK(q == 4);
    BOOST_CHECK(sign == -1);
}


/**
 *  Test if the shift in address, orbital indices and sign change correspond to the correct solutions
 *  
 *  This method does not alter the ONVs in any way.
 */
BOOST_AUTO_TEST_CASE ( shiftToPreviousOrbital_signed ) {

    GQCP::FockSpace fock_space (5, 3);
    GQCP::ONV onv = fock_space.makeONV(6);  // 10110

    size_t address_shift = 0;
    int sign = 1;

    // test shift if we plan on creating one electron and start from orbital index 2
    size_t e = 0;  // count starts at 0 (translates to orbital index 1)
    size_t q = 1;  // index starts at orbital index 1

    //  Index 1 is occupied an thus its weight shall shift if we create before an electron on a smaller index.
    //  In this instance the electron weight at index 1 should be shifted.
    //  Initial weight contribution is 1,
    //  This should be shifted to 0, the difference is 1.
    //  The sign changes (flips once)
    fock_space.shiftUntilPreviousUnoccupiedOrbital<1>(onv, address_shift, q, e, sign);

    BOOST_CHECK(address_shift == -1);
    BOOST_CHECK(e == -1);
    BOOST_CHECK(q == 0);
    BOOST_CHECK(sign == -1);

    sign = 1;
    address_shift = 0;
    onv = fock_space.makeONV(9);  // 11100
    // test shift if we plan on creating two electrons and start from orbital index 2
    e = 0;  // count starts at 1 (translates to orbital index 2)
    q = 2;  // index starts at orbital index 2

    //  Index 2 is occupied an thus its weight shall shift if we create before an electron on a smaller index.
    //  In this instance the electron weight at index 2 should be shifted.
    //  Initial weight contribution is 2,
    //  This should be shifted to 0, the difference is 2.
    //  The sign changes (flips once)
    fock_space.shiftUntilPreviousUnoccupiedOrbital<2>(onv, address_shift, q, e, sign);

    BOOST_CHECK(address_shift == -2);
    BOOST_CHECK(e == -1);
    BOOST_CHECK(q == 1);
    BOOST_CHECK(sign == -1);
}


/**
 *  Test if the Fock space correctly counts the amount of coupling ONVs with larger address for a given ONV
 */
BOOST_AUTO_TEST_CASE ( coupling_count ) {

    GQCP::FockSpace fock_space (5, 3);
    GQCP::ONV onv = fock_space.makeONV(3);  // 01110

    // We only count couplings with larger addresses

    BOOST_CHECK(fock_space.countOneElectronCouplings(onv) == 3); // 11100, 11010, 10110
    BOOST_CHECK(fock_space.countTwoElectronCouplings(onv) == 3+3);  // 11100, 11010, 10110, 11001, 10101, 10011

    onv = fock_space.makeONV(0);  // 00111

    BOOST_CHECK(fock_space.countOneElectronCouplings(onv) == 6);
    BOOST_CHECK(fock_space.countTwoElectronCouplings(onv) == 6+3); // all of them


    // test whether the total count matches that of individual counts of all ONVs in the Fock space.
    GQCP::FockSpace fock_space2 (16,8);

    size_t coupling_count1 = 0;
    size_t coupling_count2 = 0;
    onv = fock_space2.makeONV(0);  // spin string with address 0
    for (size_t I = 0; I < fock_space2.get_dimension(); I++) {  // I_alpha loops over all addresses of alpha spin strings
        if (I > 0) {
            fock_space2.setNextONV(onv);
        }
        coupling_count1 += fock_space2.countOneElectronCouplings(onv);
        coupling_count2 += fock_space2.countTwoElectronCouplings(onv);
    }

    BOOST_CHECK(2*coupling_count1 == fock_space2.countTotalOneElectronCouplings());
    BOOST_CHECK(2*coupling_count2 == fock_space2.countTotalTwoElectronCouplings());
}


/**
 *  In this test we iterate over the entire Fock space using the FockSpace::setNextONV(ONV&) 
 *  and test wether the address is correct using FockSpace::getAddress(const ONV&) 
 */
BOOST_AUTO_TEST_CASE ( ONV_address_setNext_fullspace ) {

    // Here we will test a full permutation through a Fock space of K = 15, N = 5
    GQCP::FockSpace fock_space (15, 5);

    // Retrieve the first ONV of the Fock space
    GQCP::ONV onv_test = fock_space.makeONV(0);

    const size_t dimension_fock_space = 3003;
    bool is_correct = true;  // variable that is updated to false if an unexpected result occurs

    // Iterate through the Fock space in reverse lexicographical order and test whether address matches
    for (size_t i = 0; i < dimension_fock_space; i++) {

        // Tests address
        if (i != fock_space.getAddress(onv_test)) {
            is_correct = false;
        }

        // transforms the given ONV to the next ONV in the Fock space
        if (i < dimension_fock_space - 1) {
            fock_space.setNextONV(onv_test);
        }
    }

    // Checks if no unexpected results occured in a full iteration
    BOOST_CHECK(is_correct);
}


/**
 *  Test wether the Fock space attributes the correct address to a given ONV.
 */
BOOST_AUTO_TEST_CASE ( FockSpace_getAddress ) {

    GQCP::FockSpace fock_space (6, 3);

    // The address of the string "010011" (19) should be 4
    GQCP::ONV onv (6, 3, 19);

    BOOST_CHECK_EQUAL(fock_space.getAddress(onv), 4);
}


/**
 *  Test setNext for manually chosen ONVs
 */
BOOST_AUTO_TEST_CASE ( FockSpace_setNext ) {

    GQCP::FockSpace fock_space (5, 3);
    // K = 5, N = 3 <-> "00111"
    GQCP::ONV onv = fock_space.makeONV(0);
    // The lexical permutations are: "00111" (7), "01011" (11), "01101" (13), "01110" (14), etc.

    // Check permutations one after the other

    fock_space.setNextONV(onv);  // "01011" (11)
    BOOST_CHECK_EQUAL(onv.get_unsigned_representation(), 11);
    GQCP::VectorXs x1 (3);
    x1 << 0, 1, 3;
    BOOST_CHECK(x1.isApprox(onv.get_occupation_indices()));

    fock_space.setNextONV(onv);  // "01101" (13)
    BOOST_CHECK_EQUAL(onv.get_unsigned_representation(), 13);
    GQCP::VectorXs x2 (3);
    x2 << 0, 2, 3;
    BOOST_CHECK(x2.isApprox(onv.get_occupation_indices()));

    fock_space.setNextONV(onv);  // "01110" (14)
    BOOST_CHECK_EQUAL(onv.get_unsigned_representation(), 14);
    GQCP::VectorXs x3 (3);
    x3 << 1, 2, 3;
    BOOST_CHECK(x3.isApprox(onv.get_occupation_indices()));
}


/**
 *  Perform a dense evaluation of a one-, two-electron operator and the Hamiltonian in the Fock space (including the diagonal)
 *  and compare these to the selected CI solutions.
 */
BOOST_AUTO_TEST_CASE ( FockSpace_EvaluateOperator_Dense_diagonal_true ) {

    GQCP::Molecule hchain = GQCP::Molecule::HChain(6, 0.742, 2);
    GQCP::RSpinorBasis<double, GQCP::GTOShell> spinor_basis (hchain, "STO-3G");
    spinor_basis.lowdinOrthonormalize();
    auto sq_hamiltonian = GQCP::SQHamiltonian<double>::Molecular(spinor_basis, hchain);  // in the Löwdin basis

    GQCP::FockSpace fock_space (6, 4);
    GQCP::ProductFockSpace product_fock_space (6, 4, 0);  // 4 alpha 0 beta product Fock space as selected Fock space constructor argument will mimic a spin orbital Fock space
    GQCP::SelectedFockSpace selected_fock_space (product_fock_space);

    const auto& h = sq_hamiltonian.core();
    const auto& g = sq_hamiltonian.twoElectron();

    // Test the evaluation of the operators with selected Fock space (the reference) versus that of the product Fock space 
    auto one_electron_evaluation1 = fock_space.evaluateOperatorDense(h, true);
    auto one_electron_evaluation2 = selected_fock_space.evaluateOperatorDense(h, true);

    auto two_electron_evaluation1 = fock_space.evaluateOperatorDense(g, true);
    auto two_electron_evaluation2 = selected_fock_space.evaluateOperatorDense(g, true);

    auto hamiltonian_evaluation1 = fock_space.evaluateOperatorDense(sq_hamiltonian, true);
    auto hamiltonian_evaluation2 = selected_fock_space.evaluateOperatorDense(sq_hamiltonian, true);

    BOOST_CHECK(one_electron_evaluation1.isApprox(one_electron_evaluation2));
    BOOST_CHECK(two_electron_evaluation1.isApprox(two_electron_evaluation2));
    BOOST_CHECK(hamiltonian_evaluation1.isApprox(hamiltonian_evaluation2));
}


/**
 *  Perform a dense evaluation of a one-, two-electron operator and the Hamiltonian in the Fock space (excluding the diagonal)
 *  and compare these to the selected CI solutions.
 */
BOOST_AUTO_TEST_CASE ( FockSpace_EvaluateOperator_Dense_diagonal_false ) {

    GQCP::Molecule hchain = GQCP::Molecule::HChain(6, 0.742, 2);
    GQCP::RSpinorBasis<double, GQCP::GTOShell> spinor_basis (hchain, "STO-3G");
    spinor_basis.lowdinOrthonormalize();
    auto sq_hamiltonian = GQCP::SQHamiltonian<double>::Molecular(spinor_basis, hchain);  // in the Löwdin basis

    GQCP::FockSpace fock_space (6, 4);
    GQCP::ProductFockSpace product_fock_space (6, 4, 0);  // 4 alpha 0 beta product Fock space as selected Fock space constructor argument will mimic a spin orbital Fock space
    GQCP::SelectedFockSpace selected_fock_space (product_fock_space);

    const auto& h = sq_hamiltonian.core();
    const auto& g = sq_hamiltonian.twoElectron();

    // Test the evaluation of the operators with selected Fock space (the reference) versus that of the product Fock space 
    auto one_electron_evaluation1 = fock_space.evaluateOperatorDense(h, false);
    auto one_electron_evaluation2 = selected_fock_space.evaluateOperatorDense(h, false);

    auto two_electron_evaluation1 = fock_space.evaluateOperatorDense(g, false);
    auto two_electron_evaluation2 = selected_fock_space.evaluateOperatorDense(g, false);

    auto hamiltonian_evaluation1 = fock_space.evaluateOperatorDense(sq_hamiltonian, false);
    auto hamiltonian_evaluation2 = selected_fock_space.evaluateOperatorDense(sq_hamiltonian, false);

    BOOST_CHECK(one_electron_evaluation1.isApprox(one_electron_evaluation2));
    BOOST_CHECK(two_electron_evaluation1.isApprox(two_electron_evaluation2));
    BOOST_CHECK(hamiltonian_evaluation1.isApprox(hamiltonian_evaluation2));
}


/**
 *  Perform a sparse evaluation of a one-, two-electron operator and the Hamiltonian in the Fock space (including the diagonal)
 *  and compare these to the selected CI solutions.
 */
BOOST_AUTO_TEST_CASE ( FockSpace_EvaluateOperator_Sparse_diagonal_true ) {

    GQCP::Molecule hchain = GQCP::Molecule::HChain(6, 0.742, 2);
    GQCP::RSpinorBasis<double, GQCP::GTOShell> spinor_basis (hchain, "STO-3G");
    spinor_basis.lowdinOrthonormalize();
    auto sq_hamiltonian = GQCP::SQHamiltonian<double>::Molecular(spinor_basis, hchain);  // in the Löwdin basis

    GQCP::FockSpace fock_space (6, 4);
    GQCP::ProductFockSpace product_fock_space (6, 4, 0);  // 4 alpha 0 beta product Fock space as selected Fock space constructor argument will mimic a spin orbital Fock space
    GQCP::SelectedFockSpace selected_fock_space (product_fock_space);

    const auto& h = sq_hamiltonian.core();
    const auto& g = sq_hamiltonian.twoElectron();

    // Test the evaluation of the operators with selected Fock space (the reference) versus that of the product Fock space 
    auto one_electron_evaluation1 = GQCP::SquareMatrix<double>(fock_space.evaluateOperatorSparse(h, true));
    auto one_electron_evaluation2 = GQCP::SquareMatrix<double>(selected_fock_space.evaluateOperatorSparse(h, true));

    auto two_electron_evaluation1 = GQCP::SquareMatrix<double>(fock_space.evaluateOperatorSparse(g, true));
    auto two_electron_evaluation2 = GQCP::SquareMatrix<double>(selected_fock_space.evaluateOperatorSparse(g, true));

    auto hamiltonian_evaluation1 = GQCP::SquareMatrix<double>(fock_space.evaluateOperatorSparse(sq_hamiltonian, true));
    auto hamiltonian_evaluation2 = GQCP::SquareMatrix<double>(selected_fock_space.evaluateOperatorSparse(sq_hamiltonian, true));

    BOOST_CHECK(one_electron_evaluation1.isApprox(one_electron_evaluation2));
    BOOST_CHECK(two_electron_evaluation1.isApprox(two_electron_evaluation2));
    BOOST_CHECK(hamiltonian_evaluation1.isApprox(hamiltonian_evaluation2));
}


/**
 *  Perform a sparse evaluation of a one-, two-electron operator and the Hamiltonian in the Fock space (excluding the diagonal)
 *  and compare these to the selected CI solutions.
 */
BOOST_AUTO_TEST_CASE ( FockSpace_EvaluateOperator_Sparse_diagonal_false ) {

    GQCP::Molecule hchain = GQCP::Molecule::HChain(6, 0.742, 2);
    GQCP::RSpinorBasis<double, GQCP::GTOShell> spinor_basis (hchain, "STO-3G");
    spinor_basis.lowdinOrthonormalize();
    auto sq_hamiltonian = GQCP::SQHamiltonian<double>::Molecular(spinor_basis, hchain);  // in the Löwdin basis

    GQCP::FockSpace fock_space (6, 4);
    GQCP::ProductFockSpace product_fock_space (6, 4, 0);  // 4 alpha 0 beta product Fock space as selected Fock space constructor argument will mimic a spin orbital Fock space
    GQCP::SelectedFockSpace selected_fock_space (product_fock_space);

    const auto& h = sq_hamiltonian.core();
    const auto& g = sq_hamiltonian.twoElectron();

    // Test the evaluation of the operators with selected Fock space (the reference) versus that of the product Fock space 
    auto one_electron_evaluation1 = GQCP::SquareMatrix<double>(fock_space.evaluateOperatorSparse(h, false));
    auto one_electron_evaluation2 = GQCP::SquareMatrix<double>(selected_fock_space.evaluateOperatorSparse(h, false));

    auto two_electron_evaluation1 = GQCP::SquareMatrix<double>(fock_space.evaluateOperatorSparse(g, false));
    auto two_electron_evaluation2 = GQCP::SquareMatrix<double>(selected_fock_space.evaluateOperatorSparse(g, false));

    auto hamiltonian_evaluation1 = GQCP::SquareMatrix<double>(fock_space.evaluateOperatorSparse(sq_hamiltonian, false));
    auto hamiltonian_evaluation2 = GQCP::SquareMatrix<double>(selected_fock_space.evaluateOperatorSparse(sq_hamiltonian, false));

    BOOST_CHECK(one_electron_evaluation1.isApprox(one_electron_evaluation2));
    BOOST_CHECK(two_electron_evaluation1.isApprox(two_electron_evaluation2));
    BOOST_CHECK(hamiltonian_evaluation1.isApprox(hamiltonian_evaluation2));
}


/**
 *  Evaluate the diagonal of a one-, two-electron operator and the Hamiltonian in the Fock space 
 *  and compare these to the selected CI solutions.
 */
BOOST_AUTO_TEST_CASE ( FockSpace_EvaluateOperator_diagonal ) {

    GQCP::Molecule hchain = GQCP::Molecule::HChain(6, 0.742, 2);
    GQCP::RSpinorBasis<double, GQCP::GTOShell> spinor_basis (hchain, "STO-3G");
    spinor_basis.lowdinOrthonormalize();
    auto sq_hamiltonian = GQCP::SQHamiltonian<double>::Molecular(spinor_basis, hchain);  // in the Löwdin basis

    GQCP::FockSpace fock_space (6, 4);
    GQCP::ProductFockSpace product_fock_space (6, 4, 0);  // 4 alpha 0 beta product Fock space as selected Fock space constructor argument will mimic a spin orbital Fock space
    GQCP::SelectedFockSpace selected_fock_space (product_fock_space);

    const auto& h = sq_hamiltonian.core();
    const auto& g = sq_hamiltonian.twoElectron();

    // Test the evaluation of the operators with selected Fock space (the reference) versus that of the product Fock space 
    auto one_electron_evaluation1 = fock_space.evaluateOperatorDiagonal(h);
    auto one_electron_evaluation2 = selected_fock_space.evaluateOperatorDiagonal(h);

    auto two_electron_evaluation1 = fock_space.evaluateOperatorDiagonal(g);
    auto two_electron_evaluation2 = selected_fock_space.evaluateOperatorDiagonal(g);

    auto hamiltonian_evaluation1 = fock_space.evaluateOperatorDiagonal(sq_hamiltonian);
    auto hamiltonian_evaluation2 = selected_fock_space.evaluateOperatorDiagonal(sq_hamiltonian);

    BOOST_CHECK(one_electron_evaluation1.isApprox(one_electron_evaluation2));
    BOOST_CHECK(two_electron_evaluation1.isApprox(two_electron_evaluation2));
    BOOST_CHECK(hamiltonian_evaluation1.isApprox(hamiltonian_evaluation2));
}


/**
 *  Check the Dense evaluations with diagonal to that of the Dense with the diagonal excluded + the diagonal individually for the Hamiltonian
 */
BOOST_AUTO_TEST_CASE ( FockSpace_EvaluateOperator_diagonal_vs_no_diagonal) {

    GQCP::Molecule hchain = GQCP::Molecule::HChain(6, 0.742, 2);
    GQCP::RSpinorBasis<double, GQCP::GTOShell> spinor_basis (hchain, "STO-3G");
    spinor_basis.lowdinOrthonormalize();
    auto sq_hamiltonian = GQCP::SQHamiltonian<double>::Molecular(spinor_basis, hchain);  // in the Löwdin basis

    GQCP::FockSpace fock_space (6, 4);

    GQCP::SquareMatrix<double> hamiltonian = fock_space.evaluateOperatorDense(sq_hamiltonian, true);
    GQCP::SquareMatrix<double> hamiltonian_no_diagonal = fock_space.evaluateOperatorDense(sq_hamiltonian, false);
    GQCP::VectorX<double> hamiltonian_diagonal = fock_space.evaluateOperatorDiagonal(sq_hamiltonian);

    // Test if non-diagonal evaluation and diagonal evaluations are correct
    BOOST_CHECK(hamiltonian.isApprox(hamiltonian_no_diagonal + GQCP::SquareMatrix<double>(hamiltonian_diagonal.asDiagonal())));
}


/**
 *  Perform a matrix-vector product evaluation of a one-, two-electron operator and the Hamiltonian in the Fock space
 *  and compare these to the matrix-vector product of the actual dense evaluations
 */
BOOST_AUTO_TEST_CASE ( FockSpace_EvaluateOperator_MatrixVectorProduct ) {

    GQCP::Molecule hchain = GQCP::Molecule::HChain(6, 0.742, 2);
    GQCP::RSpinorBasis<double, GQCP::GTOShell> spinor_basis (hchain, "STO-3G");
    spinor_basis.lowdinOrthonormalize();
    auto sq_hamiltonian = GQCP::SQHamiltonian<double>::Molecular(spinor_basis, hchain);  // in the Löwdin basis

    GQCP::FockSpace fock_space (6, 4);

    const auto& h = sq_hamiltonian.core();
    const auto& g = sq_hamiltonian.twoElectron();

    // Generate diagonals for the matvec input
    auto one_electron_diagonal = fock_space.evaluateOperatorDiagonal(h);
    auto two_electron_diagonal = fock_space.evaluateOperatorDiagonal(g);
    auto hamiltonian_diagonal = fock_space.evaluateOperatorDiagonal(sq_hamiltonian);

    // Test the evaluation of the operators with selected Fock space (the reference) versus that of the product Fock space 
    auto one_electron_evaluation1 = fock_space.evaluateOperatorMatrixVectorProduct(h, one_electron_diagonal, one_electron_diagonal);
    GQCP::VectorX<double> one_electron_evaluation2 = fock_space.evaluateOperatorDense(h, true) * one_electron_diagonal;

    auto two_electron_evaluation1 = fock_space.evaluateOperatorMatrixVectorProduct(g, two_electron_diagonal, two_electron_diagonal);
    GQCP::VectorX<double> two_electron_evaluation2 = fock_space.evaluateOperatorDense(g, true) * two_electron_diagonal;

    auto hamiltonian_evaluation1 = fock_space.evaluateOperatorMatrixVectorProduct(sq_hamiltonian, hamiltonian_diagonal, hamiltonian_diagonal);
    GQCP::VectorX<double> hamiltonian_evaluation2 = fock_space.evaluateOperatorDense(sq_hamiltonian, true) * hamiltonian_diagonal;

    BOOST_CHECK(one_electron_evaluation1.isApprox(one_electron_evaluation2));
    BOOST_CHECK(two_electron_evaluation1.isApprox(two_electron_evaluation2));
    BOOST_CHECK(hamiltonian_evaluation1.isApprox(hamiltonian_evaluation2));
}
