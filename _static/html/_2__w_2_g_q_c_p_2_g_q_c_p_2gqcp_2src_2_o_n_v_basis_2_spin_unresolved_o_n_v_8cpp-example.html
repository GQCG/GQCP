<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GQCP: /__w/GQCP/GQCP/gqcp/src/ONVBasis/SpinUnresolvedONV.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GQCP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/__w/GQCP/GQCP/gqcp/src/ONVBasis/SpinUnresolvedONV.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_start</td><td>the starting index (included), read from right to left </td></tr>
    <tr><td class="paramname">index_end</td><td>the ending index (not included), read from right to left</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the representation of a slice (i.e. a subset) of the ONV (read from right to left) between index_start (included) and index_end (not included)</dd></dl>
<p>"010011".slice(1, 4) =&gt; "01[001]1" -&gt; "001", where the spinor indices are: 543210</p>
<div class="fragment"><div class="line"><span class="comment">// This file is part of GQCG-GQCP.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright (C) 2017-2020  the GQCG developers</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// GQCG-GQCP is free software: you can redistribute it and/or modify</span></div>
<div class="line"><span class="comment">// it under the terms of the GNU Lesser General Public License as published by</span></div>
<div class="line"><span class="comment">// the Free Software Foundation, either version 3 of the License, or</span></div>
<div class="line"><span class="comment">// (at your option) any later version.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// GQCG-GQCP is distributed in the hope that it will be useful,</span></div>
<div class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><span class="comment">// GNU Lesser General Public License for more details.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// You should have received a copy of the GNU Lesser General Public License</span></div>
<div class="line"><span class="comment">// along with GQCG-GQCP.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;ONVBasis/SpinUnresolvedONV.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;ONVBasis/SpinUnresolvedONVBasis.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/dynamic_bitset.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_g_q_c_p.html">GQCP</a> {</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  CONSTRUCTORS</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">SpinUnresolvedONV::SpinUnresolvedONV(<span class="keyword">const</span> <span class="keywordtype">size_t</span> M, <span class="keyword">const</span> <span class="keywordtype">size_t</span> N, <span class="keyword">const</span> <span class="keywordtype">size_t</span> unsigned_representation) :</div>
<div class="line">    SpinUnresolvedONV(M, N) {</div>
<div class="line"> </div>
<div class="line">    this-&gt;unsigned_representation = unsigned_representation;</div>
<div class="line">    this-&gt;updateOccupationIndices();  <span class="comment">// throws error if the representation and N are not compatible</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SpinUnresolvedONV::SpinUnresolvedONV(<span class="keyword">const</span> <span class="keywordtype">size_t</span> M, <span class="keyword">const</span> <span class="keywordtype">size_t</span> N) :</div>
<div class="line">    M {M},</div>
<div class="line">    N {N},</div>
<div class="line">    occupied_indices(N, 0) {}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  NAMED CONSTRUCTORS</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">SpinUnresolvedONV SpinUnresolvedONV::FromString(<span class="keyword">const</span> std::string&amp; string_representation) {</div>
<div class="line"> </div>
<div class="line">    boost::dynamic_bitset&lt;&gt; intermediate_bitset {string_representation};  <span class="comment">// the least significant bit has the highest position in the string</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> M = intermediate_bitset.size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> N = intermediate_bitset.count();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> unsigned_representation = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(intermediate_bitset.to_ulong());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> SpinUnresolvedONV(M, N, unsigned_representation);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SpinUnresolvedONV SpinUnresolvedONV::FromOccupiedIndices(<span class="keyword">const</span> std::vector&lt;size_t&gt;&amp; occupied_indices, <span class="keyword">const</span> <span class="keywordtype">size_t</span> M) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Generate the corresponding unsigned representation and use that constructor.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> unsigned_representation = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; index : occupied_indices) {</div>
<div class="line">        unsigned_representation += std::pow(2, index);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> N = occupied_indices.size();</div>
<div class="line">    <span class="keywordflow">return</span> SpinUnresolvedONV(M, N, unsigned_representation);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SpinUnresolvedONV SpinUnresolvedONV::GHF(<span class="keyword">const</span> <span class="keywordtype">size_t</span> M, <span class="keyword">const</span> <span class="keywordtype">size_t</span> N, <span class="keyword">const</span> VectorX&lt;double&gt;&amp; orbital_energies) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The GHF ONV is that one in which the N spinors with the lowest energy are occupied.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create an array that contains the indices of the spinors with ascending energy.</span></div>
<div class="line">    std::vector&lt;size_t&gt; indices(M);                <span class="comment">// zero-initialized with M elements</span></div>
<div class="line">    std::iota(indices.begin(), indices.end(), 0);  <span class="comment">// start with 0</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Sort the indices according to the orbital energies.</span></div>
<div class="line">    std::stable_sort(indices.begin(), indices.end(), [&amp;orbital_energies](<span class="keyword">const</span> <span class="keywordtype">size_t</span> i, <span class="keyword">const</span> <span class="keywordtype">size_t</span> j) { return orbital_energies(i) &lt; orbital_energies(j); });</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;size_t&gt; occupied_indices {indices.begin(), indices.begin() + N};  <span class="comment">// the first N elements</span></div>
<div class="line">    <span class="keywordflow">return</span> SpinUnresolvedONV::FromOccupiedIndices(occupied_indices, M);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  OPERATORS</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">std::ostream&amp; <a name="a0"></a><a class="code" href="namespace_g_q_c_p.html#a7937d446bbf2002cbeb64115498ab03d">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> SpinUnresolvedONV&amp; onv) {</div>
<div class="line">    <span class="keywordflow">return</span> os &lt;&lt; onv.asString();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::operator==(<span class="keyword">const</span> SpinUnresolvedONV&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;unsigned_representation == other.unsigned_representation &amp;&amp; this-&gt;M == other.M;  <span class="comment">// this ensures that N, M and representation are equal</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::operator!=(<span class="keyword">const</span> SpinUnresolvedONV&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> !(this-&gt;operator==(other));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  PUBLIC METHODS</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::annihilate(<span class="keyword">const</span> <span class="keywordtype">size_t</span> p) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;isOccupied(p)) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> operator_string = 1U &lt;&lt; p;</div>
<div class="line">        this-&gt;unsigned_representation &amp;= ~operator_string;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::annihilate(<span class="keyword">const</span> <span class="keywordtype">size_t</span> p, <span class="keywordtype">int</span>&amp; sign) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;annihilate(p)) {  <span class="comment">// we have to first check if we can annihilate before applying the phase factor</span></div>
<div class="line">        sign *= this-&gt;operatorPhaseFactor(p);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::annihilateAll(<span class="keyword">const</span> std::vector&lt;size_t&gt;&amp; indices) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;areOccupied(indices)) {  <span class="comment">// only if all indices are occupied, we will annihilate</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; index : indices) {</div>
<div class="line">            this-&gt;annihilate(index);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::annihilateAll(<span class="keyword">const</span> std::vector&lt;size_t&gt;&amp; indices, <span class="keywordtype">int</span>&amp; sign) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;areOccupied(indices)) {  <span class="comment">// only if all indices are occupied, we will annihilate</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; index : indices) {</div>
<div class="line">            this-&gt;annihilate(index, sign);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::areOccupied(<span class="keyword">const</span> std::vector&lt;size_t&gt;&amp; indices)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; index : indices) {</div>
<div class="line">        <span class="keywordflow">if</span> (!this-&gt;isOccupied(index)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Only if all indices have been tested to be occupied, we can return true</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::areUnoccupied(<span class="keyword">const</span> std::vector&lt;size_t&gt;&amp; indices)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; index : indices) {</div>
<div class="line">        <span class="keywordflow">if</span> (this-&gt;isOccupied(index)) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Only if all indices have been tested to be unoccupied, we can return true</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::string SpinUnresolvedONV::asString()<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    boost::dynamic_bitset&lt;&gt; intermediate_bitset {this-&gt;M, this-&gt;unsigned_representation};</div>
<div class="line">    std::string text;  <span class="comment">// the string that will contain the textual representation of this spin-unresolved ONV</span></div>
<div class="line"> </div>
<div class="line">    boost::to_string(intermediate_bitset, text);</div>
<div class="line">    <span class="keywordflow">return</span> text;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> SpinUnresolvedONV::calculateProjection(<span class="keyword">const</span> SpinUnresolvedONV&amp; onv_on, <span class="keyword">const</span> GTransformation&lt;double&gt;&amp; C_of, <span class="keyword">const</span> GTransformation&lt;double&gt;&amp; C_on, <span class="keyword">const</span> SquareMatrix&lt;double&gt;&amp; S)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make a reference copy in order to improve readibility of the following code.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; onv_of = *<span class="keyword">this</span>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Calculate the raw matrix representation of the transformation between the spinor bases, since we&#39;re going to have to slice its rows and columns.</span></div>
<div class="line">    MatrixX&lt;double&gt; U = C_on.matrix().adjoint() * S * C_of.matrix();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// U&#39;s columns should be the ones occupied in the &#39;of&#39;-ONV.</span></div>
<div class="line">    <span class="comment">// U&#39;s rows should be the ones occupied in the &#39;on&#39;-ONV.</span></div>
<div class="line">    <span class="comment">// While waiting for Eigen 3.4 to release (which has better slicing APIs), we&#39;ll remove the UNoccupied rows/columns.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> unoccupied_indices_of = onv_of.unoccupiedIndices();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> unoccupied_indices_on = onv_on.unoccupiedIndices();</div>
<div class="line"> </div>
<div class="line">    U.removeColumns(unoccupied_indices_of);</div>
<div class="line">    U.removeRows(unoccupied_indices_on);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The requested overlap element is the determinant of the resulting matrix.</span></div>
<div class="line">    <span class="keywordflow">return</span> U.determinant();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONV::countNumberOfDifferences(<span class="keyword">const</span> SpinUnresolvedONV&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> __builtin_popcountl(this-&gt;unsigned_representation ^ other.unsigned_representation);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::create(<span class="keyword">const</span> <span class="keywordtype">size_t</span> p) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!this-&gt;isOccupied(p)) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> operator_string = 1U &lt;&lt; p;</div>
<div class="line">        this-&gt;unsigned_representation ^= operator_string;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::create(<span class="keyword">const</span> <span class="keywordtype">size_t</span> p, <span class="keywordtype">int</span>&amp; sign) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;create(p)) {  <span class="comment">// we have to first check if we can create before applying the phase factor</span></div>
<div class="line">        sign *= this-&gt;operatorPhaseFactor(p);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::createAll(<span class="keyword">const</span> std::vector&lt;size_t&gt;&amp; indices) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;areUnoccupied(indices)) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; index : indices) {</div>
<div class="line">            this-&gt;create(index);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::createAll(<span class="keyword">const</span> std::vector&lt;size_t&gt;&amp; indices, <span class="keywordtype">int</span>&amp; sign) {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;areUnoccupied(indices)) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; index : indices) {</div>
<div class="line">            this-&gt;create(index, sign);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::vector&lt;size_t&gt; SpinUnresolvedONV::findDifferentOccupations(<span class="keyword">const</span> SpinUnresolvedONV&amp; other)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> differences = this-&gt;unsigned_representation ^ other.unsigned_representation;</div>
<div class="line">    <span class="keywordtype">size_t</span> occupied_differences = differences &amp; this-&gt;unsigned_representation;  <span class="comment">// this holds all indices occupied in this, but unoccupied in other</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_occupied_differences = __builtin_popcountl(occupied_differences);</div>
<div class="line">    std::vector&lt;size_t&gt; positions;</div>
<div class="line">    positions.reserve(number_of_occupied_differences);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find the positions of the set bits in occupied_differences</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> counter = 0; counter &lt; number_of_occupied_differences; counter++) {  <span class="comment">// counts the number of occupied differences we have already encountered</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> position = __builtin_ctzl(occupied_differences);                <span class="comment">// count trailing zeros</span></div>
<div class="line">        positions.push_back(position);</div>
<div class="line"> </div>
<div class="line">        occupied_differences ^= occupied_differences &amp; -occupied_differences;  <span class="comment">// annihilate the least significant set bit</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> positions;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::vector&lt;size_t&gt; SpinUnresolvedONV::findMatchingOccupations(<span class="keyword">const</span> SpinUnresolvedONV&amp; other)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> matches = this-&gt;unsigned_representation &amp; other.unsigned_representation;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> number_of_occupied_matches = __builtin_popcountl(matches);</div>
<div class="line">    std::vector&lt;size_t&gt; positions;</div>
<div class="line">    positions.reserve(number_of_occupied_matches);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find the positions of the set bits in occupied_differences</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> counter = 0; counter &lt; number_of_occupied_matches; counter++) {  <span class="comment">// counts the number of occupied differences we have already encountered</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> position = __builtin_ctzl(matches);                         <span class="comment">// count trailing zeros</span></div>
<div class="line">        positions.push_back(position);</div>
<div class="line"> </div>
<div class="line">        matches ^= matches &amp; -matches;  <span class="comment">// annihilate the least significant set bit</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> positions;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SpinUnresolvedONV::forEach(<span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>)&gt;&amp; callback)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Loop over every electron in this ONV and retrieve the index of the spinor that it occupies.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e = 0; e &lt; this-&gt;numberOfElectrons(); e++) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> p = this-&gt;occupationIndexOf(e);</div>
<div class="line">        callback(p);</div>
<div class="line">    }  <span class="comment">// electron index loop</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SpinUnresolvedONV::forEach(<span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> <span class="keywordtype">size_t</span>, <span class="keyword">const</span> <span class="keywordtype">size_t</span>)&gt;&amp; callback)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Loop over every electron in this ONV and retrieve the index of the spinor that it occupies.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e1 = 0; e1 &lt; this-&gt;numberOfElectrons(); e1++) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> p = this-&gt;occupationIndexOf(e1);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop over every different electron in this ONV and retrieve the index of the spinor that it occupies.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e2 = 0; e2 &lt; e1; e2++) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">size_t</span> q = this-&gt;occupationIndexOf(e2);</div>
<div class="line"> </div>
<div class="line">            callback(p, q);</div>
<div class="line">        }  <span class="comment">// electron 2 index loop</span></div>
<div class="line">    }      <span class="comment">// electron 1 index loop</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::isOccupied(<span class="keyword">const</span> <span class="keywordtype">size_t</span> p)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (p &gt; this-&gt;M - 1) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONV::isOccupied(size_t): The index is out of the bitset bounds&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> operator_string = 1U &lt;&lt; p;</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;unsigned_representation &amp; operator_string;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> SpinUnresolvedONV::isUnoccupied(<span class="keyword">const</span> <span class="keywordtype">size_t</span> p)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> !this-&gt;isOccupied(p);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> SpinUnresolvedONV::operatorPhaseFactor(<span class="keyword">const</span> <span class="keywordtype">size_t</span> p)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (p == 0) {  <span class="comment">// we can&#39;t give this to this-&gt;slice(0, 0)</span></div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> m = __builtin_popcountl(this-&gt;slice(0, p));  <span class="comment">// count the number of set bits in the slice [0,p-1]</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (m % 2 == 0) {  <span class="comment">// even number of electrons: phase factor (+1)</span></div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    } <span class="keywordflow">else</span> {  <span class="comment">// odd number of electrons: phase factor (-1)</span></div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">OrbitalSpace SpinUnresolvedONV::orbitalSpace()<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create an occupied-virtual orbital space.</span></div>
<div class="line">    <span class="keywordflow">return</span> OrbitalSpace(this-&gt;occupiedIndices(), this-&gt;unoccupiedIndices());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SpinUnresolvedONV::replaceRepresentationWith(<span class="keyword">const</span> <span class="keywordtype">size_t</span> unsigned_representation) {</div>
<div class="line"> </div>
<div class="line">    this-&gt;unsigned_representation = unsigned_representation;</div>
<div class="line">    this-&gt;updateOccupationIndices();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONV::slice(<span class="keyword">const</span> <span class="keywordtype">size_t</span> index_start, <span class="keyword">const</span> <span class="keywordtype">size_t</span> index_end)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// First, do some checks</span></div>
<div class="line">    <span class="keywordflow">if</span> (index_end &lt;= index_start) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONV::slice(size_t, size_t): index_end should be larger than index_start.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (index_end &gt; this-&gt;M + 1) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONV::slice(size_t, size_t): The last slicing index index_end cannot be greater than the number of spatial orbitals M.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The union of these conditions also include the case that index_start &gt; this-&gt;M</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Shift bits to the right</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> u = this-&gt;unsigned_representation &gt;&gt; index_start;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the correct mask</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> mask_length = index_end - index_start;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> mask = ((1U) &lt;&lt; mask_length) - 1;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use the mask</span></div>
<div class="line">    <span class="keywordflow">return</span> u &amp; mask;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::vector&lt;size_t&gt; SpinUnresolvedONV::unoccupiedIndices()<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a vector containing all indices.</span></div>
<div class="line">    std::vector&lt;size_t&gt; all_indices(this-&gt;M);</div>
<div class="line">    std::iota(all_indices.begin(), all_indices.end(), 0);  <span class="comment">// fill all_indices with increasing numbers, starting by 0</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The unoccupied indices are {all indices}\{occupied indices}.</span></div>
<div class="line">    std::vector&lt;size_t&gt; unoccupied_indices;</div>
<div class="line">    std::set_difference(all_indices.begin(), all_indices.end(), this-&gt;occupied_indices.begin(), this-&gt;occupied_indices.end(),</div>
<div class="line">                        std::inserter(unoccupied_indices, unoccupied_indices.begin()));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> unoccupied_indices;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SpinUnresolvedONV::updateOccupationIndices() {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> representation_copy = this-&gt;unsigned_representation;</div>
<div class="line">    <span class="keywordtype">int</span> electron_index = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (representation_copy != 0) {</div>
<div class="line">        this-&gt;occupied_indices[electron_index] = __builtin_ctzl(representation_copy);  <span class="comment">// retrieves occupation index</span></div>
<div class="line">        electron_index++;</div>
<div class="line"> </div>
<div class="line">        representation_copy ^= (representation_copy &amp; -representation_copy);  <span class="comment">// flip the least significant bit</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (electron_index != this-&gt;N) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONV::updateOccupationIndices(): The current representation and electron count are not compatible&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace GQCP</span></div>
</div><!-- fragment --> </div><!-- contents -->
<div class="ttc" id="anamespace_g_q_c_p_html_a7937d446bbf2002cbeb64115498ab03d"><div class="ttname"><a href="namespace_g_q_c_p.html#a7937d446bbf2002cbeb64115498ab03d">GQCP::operator&lt;&lt;</a></div><div class="ttdeci">std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os, const JacobiRotation &amp;jacobi_rotation)</div><div class="ttdef"><b>Definition:</b> JacobiRotation.cpp:64</div></div>
<div class="ttc" id="anamespace_g_q_c_p_html"><div class="ttname"><a href="namespace_g_q_c_p.html">GQCP</a></div><div class="ttdef"><b>Definition:</b> BaseOneElectronIntegralBuffer.hpp:25</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
