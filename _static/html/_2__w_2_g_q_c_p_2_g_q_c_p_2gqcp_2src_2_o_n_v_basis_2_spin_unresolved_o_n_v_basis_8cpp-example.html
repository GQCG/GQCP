<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GQCP: /__w/GQCP/GQCP/gqcp/src/ONVBasis/SpinUnresolvedONVBasis.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GQCP
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/__w/GQCP/GQCP/gqcp/src/ONVBasis/SpinUnresolvedONVBasis.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Calculate the next allowed unsigned representation of a spin-unresolved ONV in this ONV basis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">representation</td><td>A representation of a spin-unresolved ONV.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next allowed unsigned representation of a spin-unresolved ONV in this ONV basis.</dd></dl>
<p>011 -&gt; 101 101 -&gt; 110</p>
<div class="fragment"><div class="line"><span class="comment">// This file is part of GQCG-GQCP.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Copyright (C) 2017-2020  the GQCG developers</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// GQCG-GQCP is free software: you can redistribute it and/or modify</span></div>
<div class="line"><span class="comment">// it under the terms of the GNU Lesser General Public License as published by</span></div>
<div class="line"><span class="comment">// the Free Software Foundation, either version 3 of the License, or</span></div>
<div class="line"><span class="comment">// (at your option) any later version.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// GQCG-GQCP is distributed in the hope that it will be useful,</span></div>
<div class="line"><span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><span class="comment">// GNU Lesser General Public License for more details.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// You should have received a copy of the GNU Lesser General Public License</span></div>
<div class="line"><span class="comment">// along with GQCG-GQCP.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;ONVBasis/SpinUnresolvedONVBasis.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/math/special_functions.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/numeric/conversion/converter.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespace_g_q_c_p.html">GQCP</a> {</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Constructors</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">SpinUnresolvedONVBasis::SpinUnresolvedONVBasis(<span class="keyword">const</span> <span class="keywordtype">size_t</span> M, <span class="keyword">const</span> <span class="keywordtype">size_t</span> N) :</div>
<div class="line">    M {M},</div>
<div class="line">    N {N} {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set up the vertex weights for the addressing scheme for a full spin-unresolved ONV basis. This addressing scheme is taken from Helgaker, Jørgensen, Olsen (2000).</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create a zero matrix of dimensions (M+1)x(N+1)</span></div>
<div class="line">    this-&gt;vertex_weights = std::vector&lt;std::vector&lt;size_t&gt;&gt;(M + 1, std::vector&lt;size_t&gt;(N + 1, 0));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// M=5   N=2</span></div>
<div class="line">    <span class="comment">// [ 0 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 0 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 0 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 0 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 0 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 0 0 0 ]</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The largest (reverse lexical) string is the one that includes the first (M-N+1) vertices of the first column</span></div>
<div class="line">    <span class="comment">//      This is because every vertical move from (p,m) to (p+1,m+1) corresponds to &quot;orbital p+1 is unoccupied&quot;.</span></div>
<div class="line">    <span class="comment">//      Therefore, the largest reverse lexical string is the one where the first (M-N) orbitals are unoccupied.</span></div>
<div class="line">    <span class="comment">//      This means that there should be (M-N) vertical moves from (0,0).</span></div>
<div class="line">    <span class="comment">// Therefore, we may only set the weights of first (M-N+1) vertices of the first column to 1.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p &lt; M - N + 1; p++) {</div>
<div class="line">        this-&gt;vertex_weights[p][0] = 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// M=5   N=2</span></div>
<div class="line">    <span class="comment">// [ 1 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 1 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 1 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 1 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 0 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 0 0 0 ]</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The recurrence relation for the vertex weights is as follows:</span></div>
<div class="line">    <span class="comment">//      Every element is the sum of the values of the element vertically above and the element left diagonally above.</span></div>
<div class="line">    <span class="comment">//      W(p,m) = W(p-1,m) + W(p-1,m-1)</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> m = 1; m &lt; N + 1; m++) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = m; p &lt; (M - N + m) + 1; p++) {</div>
<div class="line">            this-&gt;vertex_weights[p][m] = this-&gt;vertex_weights[p - 1][m] + this-&gt;vertex_weights[p - 1][m - 1];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// M=5   N=2</span></div>
<div class="line">    <span class="comment">// [ 1 0 0 ]</span></div>
<div class="line">    <span class="comment">// [ 1 1 0 ]</span></div>
<div class="line">    <span class="comment">// [ 1 2 1 ]</span></div>
<div class="line">    <span class="comment">// [ 1 3 3 ]</span></div>
<div class="line">    <span class="comment">// [ 0 4 6 ]</span></div>
<div class="line">    <span class="comment">// [ 0 0 10]</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Basic information</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::calculateDimension(<span class="keyword">const</span> <span class="keywordtype">size_t</span> M, <span class="keyword">const</span> <span class="keywordtype">size_t</span> N) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> dim_double = boost::math::binomial_coefficient&lt;double&gt;(<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(M), <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(N));</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> boost::numeric::converter&lt;size_t, double&gt;::convert(dim_double);</div>
<div class="line">    } <span class="keywordflow">catch</span> (boost::numeric::bad_numeric_cast&amp; e) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::overflow_error(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::calculateDimension(const size_t, const size_t): &quot;</span> + std::string(e.what()));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Addressing scheme, address calculations and ONV manipulations</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::arcWeight(<span class="keyword">const</span> <span class="keywordtype">size_t</span> p, <span class="keyword">const</span> <span class="keywordtype">size_t</span> n)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Arc weights and vertex weights are related. This relation is found in Helgaker, Jørgensen, Olsen (2000) in chapter 11.3.6.</span></div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;vertexWeight(p, n + 1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::addressOf(<span class="keyword">const</span> <span class="keywordtype">size_t</span> representation)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// An implementation of the formula in Helgaker, starting the addressing count from zero</span></div>
<div class="line">    <span class="keywordtype">size_t</span> copy = representation;</div>
<div class="line">    <span class="keywordtype">size_t</span> address = 0;</div>
<div class="line">    <span class="keywordtype">size_t</span> electron_count = 0;            <span class="comment">// counts the number of electrons in the spin string up to orbital p</span></div>
<div class="line">    <span class="keywordflow">while</span> (copy != 0) {                   <span class="comment">// we will remove the least significant bit each loop, we are finished when no bits are left</span></div>
<div class="line">        <span class="keywordtype">size_t</span> p = __builtin_ctzl(copy);  <span class="comment">// p is the orbital index counter (starting from 1)</span></div>
<div class="line">        electron_count++;                 <span class="comment">// each bit is an electron hence we add it up to the electron count</span></div>
<div class="line">        address += this-&gt;vertexWeight(p, electron_count);</div>
<div class="line">        copy ^= copy &amp; -copy;  <span class="comment">// flip the least significant bit</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> address;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::nextPermutationOf(<span class="keyword">const</span> <span class="keywordtype">size_t</span> representation)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// t gets this-&gt;representation&#39;s least significant 0 bits set to 1</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> t = representation | (representation - 1UL);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Next set to 1 the most significant bit to change,</span></div>
<div class="line">    <span class="comment">// set to 0 the least significant ones, and add the necessary 1 bits.</span></div>
<div class="line">    <span class="keywordflow">return</span> (t + 1UL) | (((~t &amp; (t + 1UL)) - 1UL) &gt;&gt; (__builtin_ctzl(representation) + 1UL));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::representationOf(<span class="keywordtype">size_t</span> address)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">size_t</span> representation = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (this-&gt;numberOfElectrons() != 0) {</div>
<div class="line">        representation = 0;</div>
<div class="line">        <span class="keywordtype">size_t</span> m = this-&gt;numberOfElectrons();  <span class="comment">// counts the number of electrons in the spin string up to orbital p</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = this-&gt;numberOfOrbitals(); p &gt; 0; p--) {  <span class="comment">// p is an orbital index</span></div>
<div class="line">            <span class="keywordtype">size_t</span> weight = vertexWeight(p - 1, m);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (weight &lt;= address) {  <span class="comment">// the algorithm can move diagonally, so we found an occupied orbital</span></div>
<div class="line">                address -= weight;</div>
<div class="line">                representation |= ((1) &lt;&lt; (p - 1));  <span class="comment">// set the (p-1)th bit: see (https://stackoverflow.com/a/47990)</span></div>
<div class="line"> </div>
<div class="line">                m--;  <span class="comment">// since we found an occupied orbital, we have one electron less</span></div>
<div class="line">                <span class="keywordflow">if</span> (m == 0) {</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> representation;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SpinUnresolvedONV SpinUnresolvedONVBasis::constructONVFromAddress(<span class="keyword">const</span> <span class="keywordtype">size_t</span> address)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    SpinUnresolvedONV onv {this-&gt;numberOfOrbitals(), this-&gt;numberOfElectrons()};</div>
<div class="line">    this-&gt;transformONVCorrespondingToAddress(onv, address);</div>
<div class="line">    <span class="keywordflow">return</span> onv;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SpinUnresolvedONVBasis::transformONVToNextPermutation(SpinUnresolvedONV&amp; onv)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    onv.replaceRepresentationWith(this-&gt;nextPermutationOf(onv.unsignedRepresentation()));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SpinUnresolvedONVBasis::transformONVCorrespondingToAddress(SpinUnresolvedONV&amp; onv, <span class="keyword">const</span> <span class="keywordtype">size_t</span> address)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    onv.replaceRepresentationWith(this-&gt;representationOf(address));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Couplings</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::countOneElectronCouplings(<span class="keyword">const</span> SpinUnresolvedONV&amp; onv)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> V = this-&gt;numberOfOrbitals() - this-&gt;numberOfElectrons();  <span class="comment">// number of virtual orbitals</span></div>
<div class="line">    <span class="keywordtype">size_t</span> coupling_count = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e1 = 0; e1 &lt; this-&gt;numberOfElectrons(); e1++) {</div>
<div class="line">        <span class="keywordtype">size_t</span> p = onv.occupationIndexOf(e1);</div>
<div class="line">        coupling_count += (V + e1 - p);  <span class="comment">// number of virtuals with an index larger than p</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> coupling_count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::countTotalOneElectronCouplings()<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> M = this-&gt;numberOfOrbitals();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> N = this-&gt;numberOfElectrons();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (M - N) * N * (this-&gt;dimension());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::countTotalTwoElectronCouplings()<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> M = this-&gt;numberOfOrbitals();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> N = this-&gt;numberOfElectrons();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> two_electron_permutation = 0;  <span class="comment">// all distributions for two electrons over the virtual orbitals</span></div>
<div class="line">    <span class="keywordflow">if</span> (M - N &gt;= 2) {</div>
<div class="line">        two_electron_permutation = SpinUnresolvedONVBasis::calculateDimension(M - N, 2) * N * (N - 1) * (this-&gt;dimension()) / 2;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> two_electron_permutation + countTotalOneElectronCouplings();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">size_t</span> SpinUnresolvedONVBasis::countTwoElectronCouplings(<span class="keyword">const</span> SpinUnresolvedONV&amp; onv)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> M = this-&gt;numberOfOrbitals();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> N = this-&gt;numberOfElectrons();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> V = M - N;  <span class="comment">// number of virtual orbitals</span></div>
<div class="line">    <span class="keywordtype">size_t</span> coupling_count = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e1 = 0; e1 &lt; N; e1++) {</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">size_t</span> p = onv.occupationIndexOf(e1);</div>
<div class="line">        coupling_count += (V + e1 - p);  <span class="comment">//  one electron part</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e2 = e1 + 1; e2 &lt; N; e2++) {</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">size_t</span> q = onv.occupationIndexOf(e2);</div>
<div class="line">            <span class="keywordtype">size_t</span> coupling_count2 = (V + e2 - q);</div>
<div class="line">            coupling_count += (V - coupling_count2) * coupling_count2;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (coupling_count2 &gt; 1) {</div>
<div class="line">                coupling_count += SpinUnresolvedONVBasis::calculateDimension(coupling_count2, 2);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> coupling_count;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">std::vector&lt;Eigen::SparseMatrix&lt;double&gt;&gt; SpinUnresolvedONVBasis::calculateOneElectronCouplings()<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> K = this-&gt;numberOfOrbitals();</div>
<div class="line">    <span class="keywordtype">size_t</span> N = this-&gt;numberOfElectrons();</div>
<div class="line">    <span class="keywordtype">size_t</span> dim = this-&gt;dimension();</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::vector&lt;Eigen::Triplet&lt;double&gt;&gt;&gt; sparse_entries(K * (K + 1) / 2);</div>
<div class="line">    std::vector&lt;Eigen::SparseMatrix&lt;double&gt;&gt; sparse_matrices(K * (K + 1) / 2, Eigen::SparseMatrix&lt;double&gt;(dim, dim));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (N == 0) {</div>
<div class="line">        <span class="keywordflow">return</span> sparse_matrices;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Reserve appropriate number of entries</span></div>
<div class="line">    <span class="keywordtype">size_t</span> reservation_size = SpinUnresolvedONVBasis::calculateDimension(K - 1, N - 1);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> p = 0; p &lt; K; p++) {</div>
<div class="line">        sparse_entries[p * (K + K + 1 - p) / 2].reserve(reservation_size);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> q = p + 1; q &lt; K; q++) {</div>
<div class="line">            sparse_entries[p * (K + K + 1 - p) / 2 + q - p].reserve(2 * reservation_size);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    SpinUnresolvedONV onv = this-&gt;constructONVFromAddress(0);  <span class="comment">// onv with address 0</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> I = 0; I &lt; dim; I++) {                         <span class="comment">// I loops over all the addresses of the onv</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e1 = 0; e1 &lt; N; e1++) {                    <span class="comment">// e1 (electron 1) loops over the (number of) electrons</span></div>
<div class="line">            <span class="keywordtype">size_t</span> p = onv.occupationIndexOf(e1);              <span class="comment">// retrieve the index of a given electron</span></div>
<div class="line">            <span class="comment">// remove the weight from the initial address I, because we annihilate</span></div>
<div class="line">            <span class="keywordtype">size_t</span> address = I - this-&gt;vertexWeight(p, e1 + 1);</div>
<div class="line">            <span class="comment">// The e2 iteration counts the number of encountered electrons for the creation operator</span></div>
<div class="line">            <span class="comment">// We only consider greater addresses than the initial one (because of symmetry)</span></div>
<div class="line">            <span class="comment">// Hence we only count electron after the annihilated electron (e1)</span></div>
<div class="line">            sparse_entries[p * (K + K + 1 - p) / 2].emplace_back(I, I, 1);</div>
<div class="line">            <span class="keywordtype">size_t</span> e2 = e1 + 1;</div>
<div class="line">            <span class="keywordtype">size_t</span> q = p + 1;</div>
<div class="line">            <span class="keywordtype">int</span> sign_e2 = 1;</div>
<div class="line">            <span class="comment">// perform a shift</span></div>
<div class="line">            this-&gt;shiftUntilNextUnoccupiedOrbital&lt;1&gt;(onv, address, q, e2, sign_e2);</div>
<div class="line">            <span class="keywordflow">while</span> (q &lt; K) {</div>
<div class="line">                <span class="keywordtype">size_t</span> J = address + this-&gt;vertexWeight(q, e2);</div>
<div class="line"> </div>
<div class="line">                sparse_entries[p * (K + K + 1 - p) / 2 + q - p].emplace_back(I, J, sign_e2);</div>
<div class="line">                sparse_entries[p * (K + K + 1 - p) / 2 + q - p].emplace_back(J, I, sign_e2);</div>
<div class="line"> </div>
<div class="line">                q++;  <span class="comment">// go to the next orbital</span></div>
<div class="line">                <span class="comment">// perform a shift</span></div>
<div class="line">                this-&gt;shiftUntilNextUnoccupiedOrbital&lt;1&gt;(onv, address, q, e2, sign_e2);</div>
<div class="line">            }  <span class="comment">//  (creation)</span></div>
<div class="line">        }      <span class="comment">// e1 loop (annihilation)</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Prevent last permutation</span></div>
<div class="line">        <span class="keywordflow">if</span> (I &lt; dim - 1) {</div>
<div class="line">            this-&gt;transformONVToNextPermutation(onv);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; K * (K + 1) / 2; k++) {</div>
<div class="line">        sparse_matrices[k].setFromTriplets(sparse_entries[k].begin(), sparse_entries[k].end());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> sparse_matrices;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Iterating</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> SpinUnresolvedONVBasis::forEach(<span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> SpinUnresolvedONV&amp;, <span class="keyword">const</span> <span class="keywordtype">size_t</span>)&gt;&amp; callback)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> dim = this-&gt;dimension();</div>
<div class="line">    SpinUnresolvedONV onv = this-&gt;constructONVFromAddress(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Loop over all addresses of the ONVs.</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> I = 0; I &lt; dim; I++) {</div>
<div class="line"> </div>
<div class="line">        callback(onv, I);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Prevent the last permutation from occurring, as this would cause errors.</span></div>
<div class="line">        <span class="keywordflow">if</span> (I &lt; dim - 1) {</div>
<div class="line">            this-&gt;transformONVToNextPermutation(onv);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Dense generalized operator evaluations</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">SquareMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorDense(<span class="keyword">const</span> ScalarGSQOneElectronOperator&lt;double&gt;&amp; f)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (f.numberOfOrbitals() != this-&gt;numberOfOrbitals()) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::evaluateOperatorDense(const ScalarGSQOneElectronOperator&lt;double&gt;&amp;): The number of orbitals of this ONV basis and the given one-electron operator are incompatible.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize a container for the dense matrix representation, and fill it with the general evaluation function.</span></div>
<div class="line">    MatrixRepresentationEvaluationContainer&lt;SquareMatrix&lt;double&gt;&gt; container {this-&gt;dimension()};</div>
<div class="line">    this-&gt;evaluate&lt;SquareMatrix&lt;double&gt;&gt;(f, container);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> container.evaluation();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SquareMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorDense(<span class="keyword">const</span> ScalarGSQTwoElectronOperator&lt;double&gt;&amp; g)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// In order to avoid duplicate code, we choose to delegate this method to the evaluation of a `GSQHamiltonian` that contains no core contributions. This does not affect performance significantly, because the bottleneck will always be the iteration over the whole ONV basis.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> zero = <a name="a0"></a><a class="code" href="class_g_q_c_p_1_1_s_q_operator_storage_base.html#aae57f5b84d06fde585c7597e2b6e225b">ScalarGSQOneElectronOperator&lt;double&gt;::Zero</a>(g.numberOfOrbitals());</div>
<div class="line">    <span class="keyword">const</span> GSQHamiltonian&lt;double&gt; hamiltonian {zero, g};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;evaluateOperatorDense(hamiltonian);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SquareMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorDense(<span class="keyword">const</span> GSQHamiltonian&lt;double&gt;&amp; hamiltonian)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (hamiltonian.numberOfOrbitals() != this-&gt;numberOfOrbitals()) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::evaluateOperatorDense(const USQHamiltonian&lt;double&gt;&amp;): The number of orbitals of this ONV basis and the given Hamiltonian are incompatible.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize a container for the dense matrix representation, and fill it with the general evaluation function.</span></div>
<div class="line">    MatrixRepresentationEvaluationContainer&lt;SquareMatrix&lt;double&gt;&gt; container {this-&gt;dimension()};</div>
<div class="line">    this-&gt;evaluate&lt;SquareMatrix&lt;double&gt;&gt;(hamiltonian, container);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> container.evaluation();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Dense unrestricted operator evaluations</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">SquareMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorDense(<span class="keyword">const</span> ScalarUSQOneElectronOperatorComponent&lt;double&gt;&amp; f)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We may convert an unrestricted component into the generalized representation.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> f_generalized = <a name="a1"></a><a class="code" href="class_g_q_c_p_1_1_g_s_q_one_electron_operator.html#a03c6e36fce8838f941b3ffdb167c2a4d">ScalarGSQOneElectronOperator&lt;double&gt;::FromUnrestrictedComponent</a>(f);</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;evaluateOperatorDense(f_generalized);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">SquareMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorDense(<span class="keyword">const</span> ScalarPureUSQTwoElectronOperatorComponent&lt;double&gt;&amp; g)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We may convert an unrestricted component into the generalized representation.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> g_generalized = <a name="a2"></a><a class="code" href="class_g_q_c_p_1_1_g_s_q_two_electron_operator.html#a884709eb9236aa9975d016ee93322d13">ScalarGSQTwoElectronOperator&lt;double&gt;::FromUnrestrictedComponent</a>(g);</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;evaluateOperatorDense(g_generalized);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Diagonal generalized operator evaluations</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">VectorX&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorDiagonal(<span class="keyword">const</span> ScalarGSQOneElectronOperator&lt;double&gt;&amp; f_op)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> K = f_op.numberOfOrbitals();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (K != this-&gt;numberOfOrbitals()) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::evaluateOperatorDiagonal(const ScalarGSQOneElectronOperator&lt;double&gt;&amp;): The number of orbitals of this ONV basis and the given operator are incompatible.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Prepare some variables.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; f = f_op.parameters();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> N = this-&gt;numberOfElectrons();</div>
<div class="line">    <span class="keywordtype">size_t</span> dim = this-&gt;dimension();</div>
<div class="line"> </div>
<div class="line">    VectorX&lt;double&gt; diagonal = VectorX&lt;double&gt;::Zero(dim);</div>
<div class="line"> </div>
<div class="line">    SpinUnresolvedONV onv = this-&gt;constructONVFromAddress(0);  <span class="comment">// onv with address 0</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> I = 0; I &lt; dim; I++) {                         <span class="comment">// I loops over all addresses in this ONV basis</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (I &gt; 0) {</div>
<div class="line">            this-&gt;transformONVToNextPermutation(onv);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e1 = 0; e1 &lt; N; e1++) {  <span class="comment">// A1 (annihilation 1)</span></div>
<div class="line">            <span class="keywordtype">size_t</span> p = onv.occupationIndexOf(e1);</div>
<div class="line">            diagonal(I) += f(p, p);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> diagonal;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">VectorX&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorDiagonal(<span class="keyword">const</span> ScalarGSQTwoElectronOperator&lt;double&gt;&amp; g_op)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> K = g_op.numberOfOrbitals();</div>
<div class="line">    <span class="keywordflow">if</span> (K != this-&gt;numberOfOrbitals()) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::evaluateOperatorDiagonal(const ScalarGSQTwoElectronOperator&lt;double&gt;&amp;): The number of orbitals of this ONV basis and the given operator are incompatible.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> N = this-&gt;numberOfElectrons();</div>
<div class="line">    <span class="keywordtype">size_t</span> dim = this-&gt;dimension();</div>
<div class="line"> </div>
<div class="line">    VectorX&lt;double&gt; diagonal = VectorX&lt;double&gt;::Zero(dim);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> k = g_op.effectiveOneElectronPartition().parameters();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; g = g_op.parameters();</div>
<div class="line"> </div>
<div class="line">    SpinUnresolvedONV onv = this-&gt;constructONVFromAddress(0);  <span class="comment">// onv with address 0</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> I = 0; I &lt; dim; I++) {                         <span class="comment">// I loops over all addresses in this ONV basis</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (I &gt; 0) {</div>
<div class="line">            this-&gt;transformONVToNextPermutation(onv);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> e1 = 0; e1 &lt; N; e1++) {  <span class="comment">// A1 (annihilation 1)</span></div>
<div class="line">            <span class="keywordtype">size_t</span> p = onv.occupationIndexOf(e1);</div>
<div class="line">            diagonal(I) += k(p, p);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> q = 0; q &lt; K; q++) {  <span class="comment">// q loops over SOs</span></div>
<div class="line">                <span class="keywordflow">if</span> (onv.isOccupied(q)) {</div>
<div class="line">                    diagonal(I) += 0.5 * g(p, p, q, q);</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    diagonal(I) += 0.5 * g(p, q, q, p);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> diagonal;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">VectorX&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorDiagonal(<span class="keyword">const</span> GSQHamiltonian&lt;double&gt;&amp; sq_hamiltonian)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;evaluateOperatorDiagonal(sq_hamiltonian.core()) + this-&gt;evaluateOperatorDiagonal(sq_hamiltonian.twoElectron());</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Sparse generalized operator evaluations</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">Eigen::SparseMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorSparse(<span class="keyword">const</span> ScalarGSQOneElectronOperator&lt;double&gt;&amp; f)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (f.numberOfOrbitals() != this-&gt;numberOfOrbitals()) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::evaluateOperatorSparse(const ScalarGSQOneElectronOperator&lt;double&gt;&amp;): The number of orbitals of the ONV basis and the operator are incompatible.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize a container for the sparse matrix representation, and reserve an appropriate amount of memory for it.</span></div>
<div class="line">    MatrixRepresentationEvaluationContainer&lt;Eigen::SparseMatrix&lt;double&gt;&gt; container {this-&gt;dimension()};</div>
<div class="line">    <span class="keywordtype">size_t</span> memory = this-&gt;dimension() + this-&gt;countTotalOneElectronCouplings();</div>
<div class="line">    container.reserve(memory);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Evaluate the one-electron operator and add the evaluations to the sparse matrix representation.</span></div>
<div class="line">    this-&gt;evaluate&lt;Eigen::SparseMatrix&lt;double&gt;&gt;(f, container);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Finalize the creation of the sparse matrix and return the result.</span></div>
<div class="line">    container.addToMatrix();</div>
<div class="line">    <span class="keywordflow">return</span> container.evaluation();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Eigen::SparseMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorSparse(<span class="keyword">const</span> ScalarGSQTwoElectronOperator&lt;double&gt;&amp; g)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// In order to avoid duplicate code, we choose to delegate this method to the evaluation of a `GSQHamiltonian` that contains no core contributions. This does not affect performance significantly, because the bottleneck will always be the iteration over the whole ONV basis.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> zero = <a class="code" href="class_g_q_c_p_1_1_s_q_operator_storage_base.html#aae57f5b84d06fde585c7597e2b6e225b">ScalarGSQOneElectronOperator&lt;double&gt;::Zero</a>(g.numberOfOrbitals());</div>
<div class="line">    <span class="keyword">const</span> GSQHamiltonian&lt;double&gt; hamiltonian {zero, g};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;evaluateOperatorSparse(hamiltonian);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Eigen::SparseMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorSparse(<span class="keyword">const</span> GSQHamiltonian&lt;double&gt;&amp; hamiltonian)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (hamiltonian.numberOfOrbitals() != this-&gt;numberOfOrbitals()) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::evaluateOperatorSparse(const GSQHamiltonian&lt;double&gt;&amp; hamiltonian): The number of orbitals of this ONV basis and the given Hamiltonian are incompatible.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize a container for the sparse matrix representation, and reserve an appropriate amount of memory for it.</span></div>
<div class="line">    MatrixRepresentationEvaluationContainer&lt;Eigen::SparseMatrix&lt;double&gt;&gt; container {this-&gt;dimension()};</div>
<div class="line">    <span class="keywordtype">size_t</span> memory = this-&gt;dimension() + this-&gt;countTotalTwoElectronCouplings();</div>
<div class="line">    container.reserve(memory);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Evaluate the Hamiltonian and add the evaluations to the sparse matrix representation.</span></div>
<div class="line">    this-&gt;evaluate&lt;Eigen::SparseMatrix&lt;double&gt;&gt;(hamiltonian, container);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Finalize the creation of the sparse matrix and return the result.</span></div>
<div class="line">    container.addToMatrix();</div>
<div class="line">    <span class="keywordflow">return</span> container.evaluation();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Sparse unrestricted operator evaluations</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">Eigen::SparseMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorSparse(<span class="keyword">const</span> ScalarUSQOneElectronOperatorComponent&lt;double&gt;&amp; f)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We may convert an unrestricted component into the generalized representation.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> f_generalized = <a class="code" href="class_g_q_c_p_1_1_g_s_q_one_electron_operator.html#a03c6e36fce8838f941b3ffdb167c2a4d">ScalarGSQOneElectronOperator&lt;double&gt;::FromUnrestrictedComponent</a>(f);</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;evaluateOperatorSparse(f_generalized);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Eigen::SparseMatrix&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorSparse(<span class="keyword">const</span> ScalarPureUSQTwoElectronOperatorComponent&lt;double&gt;&amp; g)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We may convert an unrestricted component into the generalized representation.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> g_generalized = <a class="code" href="class_g_q_c_p_1_1_g_s_q_two_electron_operator.html#a884709eb9236aa9975d016ee93322d13">ScalarGSQTwoElectronOperator&lt;double&gt;::FromUnrestrictedComponent</a>(g);</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;evaluateOperatorSparse(g_generalized);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> *  MARK: Generalized matrix-vector product evaluations</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line">VectorX&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorMatrixVectorProduct(<span class="keyword">const</span> ScalarGSQOneElectronOperator&lt;double&gt;&amp; f, <span class="keyword">const</span> VectorX&lt;double&gt;&amp; <a name="a3"></a><a class="code" href="namespace_g_q_c_p.html#ac4c016a1668ae66892e5b4d8846613e8a2bb47fa9aafe67dde5d4e205193140b5">x</a>)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (f.numberOfOrbitals() != this-&gt;numberOfOrbitals()) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::evaluateOperatorMatrixVectorProduct(const ScalarGSQOneElectronOperator&lt;double&gt;&amp;, const VectorX&lt;double&gt;&amp;): The number of orbitals of this ONV basis and the operator are incompatible.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize a container for the matrix-vector product, and fill it with the general evaluation function.</span></div>
<div class="line">    MatrixRepresentationEvaluationContainer&lt;VectorX&lt;double&gt;&gt; container {<a class="code" href="namespace_g_q_c_p.html#ac4c016a1668ae66892e5b4d8846613e8a2bb47fa9aafe67dde5d4e205193140b5">x</a>};</div>
<div class="line">    this-&gt;evaluate&lt;VectorX&lt;double&gt;&gt;(f, container);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> container.evaluation();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">VectorX&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorMatrixVectorProduct(<span class="keyword">const</span> ScalarGSQTwoElectronOperator&lt;double&gt;&amp; g, <span class="keyword">const</span> VectorX&lt;double&gt;&amp; <a class="code" href="namespace_g_q_c_p.html#ac4c016a1668ae66892e5b4d8846613e8a2bb47fa9aafe67dde5d4e205193140b5">x</a>)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// In order to avoid duplicate code, we choose to delegate this method to the evaluation of a `GSQHamiltonian` that contains no core contributions. This does not affect performance significantly, because the bottleneck will always be the iteration over the whole ONV basis.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> zero = <a class="code" href="class_g_q_c_p_1_1_s_q_operator_storage_base.html#aae57f5b84d06fde585c7597e2b6e225b">ScalarGSQOneElectronOperator&lt;double&gt;::Zero</a>(g.numberOfOrbitals());</div>
<div class="line">    <span class="keyword">const</span> GSQHamiltonian&lt;double&gt; hamiltonian {zero, g};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;evaluateOperatorMatrixVectorProduct(hamiltonian, <a class="code" href="namespace_g_q_c_p.html#ac4c016a1668ae66892e5b4d8846613e8a2bb47fa9aafe67dde5d4e205193140b5">x</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">VectorX&lt;double&gt; SpinUnresolvedONVBasis::evaluateOperatorMatrixVectorProduct(<span class="keyword">const</span> GSQHamiltonian&lt;double&gt;&amp; hamiltonian, <span class="keyword">const</span> VectorX&lt;double&gt;&amp; <a class="code" href="namespace_g_q_c_p.html#ac4c016a1668ae66892e5b4d8846613e8a2bb47fa9aafe67dde5d4e205193140b5">x</a>)<span class="keyword"> const </span>{</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (hamiltonian.numberOfOrbitals() != this-&gt;numberOfOrbitals()) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;SpinUnresolvedONVBasis::evaluateOperatorMatrixVectorProduct(const USQHamiltonian&lt;double&gt;&amp;, const VectorX&lt;double&gt;&amp; x): The number of orbitals of this ONV basis and the given Hamiltonian are incompatible.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize a container for the matrix-vector product, and fill it with the general evaluation function.</span></div>
<div class="line">    MatrixRepresentationEvaluationContainer&lt;VectorX&lt;double&gt;&gt; container {<a class="code" href="namespace_g_q_c_p.html#ac4c016a1668ae66892e5b4d8846613e8a2bb47fa9aafe67dde5d4e205193140b5">x</a>};</div>
<div class="line">    this-&gt;evaluate&lt;VectorX&lt;double&gt;&gt;(hamiltonian, container);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> container.evaluation();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace GQCP</span></div>
</div><!-- fragment --> </div><!-- contents -->
<div class="ttc" id="anamespace_g_q_c_p_html_ac4c016a1668ae66892e5b4d8846613e8a2bb47fa9aafe67dde5d4e205193140b5"><div class="ttname"><a href="namespace_g_q_c_p.html#ac4c016a1668ae66892e5b4d8846613e8a2bb47fa9aafe67dde5d4e205193140b5">GQCP::x</a></div><div class="ttdeci">@ x</div><div class="ttdef"><b>Definition:</b> CartesianDirection.hpp:28</div></div>
<div class="ttc" id="aclass_g_q_c_p_1_1_g_s_q_one_electron_operator_html_a03c6e36fce8838f941b3ffdb167c2a4d"><div class="ttname"><a href="class_g_q_c_p_1_1_g_s_q_one_electron_operator.html#a03c6e36fce8838f941b3ffdb167c2a4d">GQCP::GSQOneElectronOperator::FromUnrestrictedComponent</a></div><div class="ttdeci">static GSQOneElectronOperator&lt; Scalar, Vectorizer &gt; FromUnrestrictedComponent(const USQOneElectronOperatorComponent&lt; Scalar, Vectorizer &gt; &amp;f_component)</div><div class="ttdef"><b>Definition:</b> GSQOneElectronOperator.hpp:71</div></div>
<div class="ttc" id="anamespace_g_q_c_p_html"><div class="ttname"><a href="namespace_g_q_c_p.html">GQCP</a></div><div class="ttdef"><b>Definition:</b> BaseOneElectronIntegralBuffer.hpp:25</div></div>
<div class="ttc" id="aclass_g_q_c_p_1_1_g_s_q_two_electron_operator_html_a884709eb9236aa9975d016ee93322d13"><div class="ttname"><a href="class_g_q_c_p_1_1_g_s_q_two_electron_operator.html#a884709eb9236aa9975d016ee93322d13">GQCP::GSQTwoElectronOperator::FromUnrestrictedComponent</a></div><div class="ttdeci">static GSQTwoElectronOperator&lt; Scalar, Vectorizer &gt; FromUnrestrictedComponent(const PureUSQTwoElectronOperatorComponent&lt; Scalar, Vectorizer &gt; &amp;g_component)</div><div class="ttdef"><b>Definition:</b> GSQTwoElectronOperator.hpp:72</div></div>
<div class="ttc" id="aclass_g_q_c_p_1_1_s_q_operator_storage_base_html_aae57f5b84d06fde585c7597e2b6e225b"><div class="ttname"><a href="class_g_q_c_p_1_1_s_q_operator_storage_base.html#aae57f5b84d06fde585c7597e2b6e225b">GQCP::SQOperatorStorageBase&lt; SquareMatrix&lt; _Scalar &gt;, _Vectorizer, SimpleSQOneElectronOperator&lt; _Scalar, _Vectorizer, GSQOneElectronOperator&lt; _Scalar, _Vectorizer &gt; &gt; &gt;::Zero</a></div><div class="ttdeci">static FinalOperator Zero(const size_t dim, const Vectorizer &amp;vectorizer)</div><div class="ttdef"><b>Definition:</b> SQOperatorStorageBase.hpp:145</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
